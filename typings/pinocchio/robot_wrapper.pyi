"""
This type stub file was generated by pyright.
"""

class RobotWrapper:
    @staticmethod
    def BuildFromURDF(filename, *args, **kwargs): # -> RobotWrapper:
        ...
    
    def initFromURDF(self, filename, *args, **kwargs): # -> None:
        ...
    
    @staticmethod
    def BuildFromSDF(filename, *args, **kwargs): # -> RobotWrapper:
        ...
    
    def initFromSDF(self, filename, *args, **kwargs): # -> None:
        ...
    
    @staticmethod
    def BuildFromMJCF(filename, *args, **kwargs): # -> RobotWrapper:
        ...
    
    def initFromMJCF(self, filename, *args, **kwargs): # -> None:
        ...
    
    def __init__(self, model=..., collision_model=..., visual_model=..., verbose=...) -> None:
        ...
    
    @property
    def nq(self):
        ...
    
    @property
    def nv(self):
        ...
    
    def com(self, q=..., v=..., a=...): # -> tuple[Any, Any] | tuple[Any, Any, Any]:
        ...
    
    def vcom(self, q, v):
        ...
    
    def acom(self, q, v, a):
        ...
    
    def centroidalMomentum(self, q, v):
        ...
    
    def centroidalMap(self, q):
        """
        Computes the centroidal momentum matrix which maps from the joint velocity
        vector to the centroidal momentum expressed around the center of mass.
        """
        ...
    
    def centroidal(self, q, v): # -> tuple[Any, Any, Any]:
        """
        Computes all the quantities related to the centroidal dynamics (hg, Ag and Ig),
        corresponding to the centroidal momentum, the centroidal map and the centroidal
        rigid inertia.
        """
        ...
    
    def centroidalMomentumVariation(self, q, v, a):
        ...
    
    def Jcom(self, q):
        ...
    
    def mass(self, q):
        ...
    
    def nle(self, q, v):
        ...
    
    def gravity(self, q):
        ...
    
    def forwardKinematics(self, q, v=..., a=...): # -> None:
        ...
    
    def placement(self, q, index, update_kinematics=...):
        ...
    
    def velocity(self, q, v, index, update_kinematics=..., reference_frame=...):
        ...
    
    def acceleration(self, q, v, a, index, update_kinematics=..., reference_frame=...):
        ...
    
    def classicalAcceleration(self, q, v, a, index, update_kinematics=..., reference_frame=...):
        ...
    
    def framePlacement(self, q, index, update_kinematics=...):
        ...
    
    def frameVelocity(self, q, v, index, update_kinematics=..., reference_frame=...):
        ...
    
    def frameAcceleration(self, q, v, a, index, update_kinematics=..., reference_frame=...):
        ...
    
    def frameClassicalAcceleration(self, q, v, a, index, update_kinematics=..., reference_frame=...):
        ...
    
    def computeJointJacobian(self, q, index):
        ...
    
    def getJointJacobian(self, index, rf_frame=...):
        ...
    
    def computeJointJacobians(self, q):
        ...
    
    def updateGeometryPlacements(self, q=..., visual=...): # -> None:
        ...
    
    def framesForwardKinematics(self, q): # -> None:
        ...
    
    def buildReducedRobot(self, list_of_joints_to_lock, reference_configuration=...): # -> RobotWrapper:
        """
        Build a reduced robot model given a list of joints to lock.
        Parameters:
        \tlist_of_joints_to_lock: list of joint indexes/names to lock.
        \treference_configuration: reference configuration to compute the
        placement of the lock joints. If not provided, reference_configuration
        defaults to the robot's neutral configuration.

        Returns: a new robot model.
        """
        ...
    
    def getFrameJacobian(self, frame_id, rf_frame=...):
        """
        It computes the Jacobian of frame given by its id (frame_id) either expressed in
        the local coordinate frame or in the world coordinate frame.
        """
        ...
    
    def computeFrameJacobian(self, q, frame_id):
        """
        Similar to getFrameJacobian but does not need pin.computeJointJacobians and
        pin.updateFramePlacements to update internal value of self.data related to
        frames.
        """
        ...
    
    def rebuildData(self): # -> None:
        """Re-build the data objects. Needed if the models were modified.
        Warning: this will delete any information stored in all data objects."""
        ...
    
    def index(self, name):
        ...
    
    @property
    def viewer(self): # -> Any:
        ...
    
    def setVisualizer(self, visualizer, init=..., copy_models=...): # -> None:
        """
        Set the visualizer. If init is True, the visualizer is initialized with this
        wrapper's models.  If copy_models is also True, the models are copied.
        Otherwise, they are simply kept as a reference.
        """
        ...
    
    def getViewerNodeName(self, geometry_object, geometry_type): # -> Any:
        """
        For each geometry object, returns the corresponding name of the node in the
        display.
        """
        ...
    
    def initViewer(self, share_data=..., *args, **kwargs): # -> None:
        """Init the viewer"""
        ...
    
    def loadViewerModel(self, *args, **kwargs): # -> None:
        """Create the scene displaying the robot meshes in MeshCat"""
        ...
    
    def display(self, q): # -> None:
        """
        Display the robot at configuration q in the viewer by placing all the bodies.
        """
        ...
    
    def displayCollisions(self, visibility): # -> None:
        """Set whether to diplay collision objects or not"""
        ...
    
    def displayVisuals(self, visibility): # -> None:
        """Set whether to diplay visual objects or not"""
        ...
    
    def play(self, q_trajectory, dt): # -> None:
        """Play a trajectory with given time step"""
        ...
    


__all__ = ["RobotWrapper"]
